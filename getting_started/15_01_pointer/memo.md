# Pointer

## memo

### ポインタ変数のもっとも基本的な使い方
- ポインタ変数モードの時に読み書きしたいメモリのアドレスを代入して、
- その後、通常変数モードに切り替えてそのメモリを操作する。

>前節で説明した通り、ポインタ変数は、2モードを持っています。
それは、通常変数モードと、ポインタ変数モードです。
とくに何も指定せずにポインタ変数を使っている場合はポインタ変数モードになります。
通常変数モードに切り替えるには、変数の前に*記号をつけます。
*記号がつけられたポインタ変数は、通常変数とまったく同じ機能になります。
次のプログラムは、ポインタ変数を通常変数モードに切り替えて使う例です。

```c
#include <stdio.h>

int main(void)
{
    int *p;
    int i;
    // ①ポインタ変数モード
    // 読み書きしたいメモリのアドレスを代入する
    p = &i;
    // ②通常変数モード
    // 通常変数モードに切り替えて、そのメモリアドレスの値を操作する
    *p = 10; 
    printf("*p = %d\n", *p);
    printf("i = %d\n", i);
    return 0;
}
// ➜  12_pointer git:(main) ✗ gcc -o 06_pointer 06_pointer.c && ./06_pointer
// *p = 10
// i = 10
```

ポインタの使われ方
>直接、何番のメモリを書き換えろ、と指定するのではなくて、
>書き換えたいメモリのアドレスを代入し、モードを切り替えて書き換える、という、
>いわば2段構になっている
>変数iと通常変数モードの*pは、
>まったく同じメモリ領域を使っているということです。
>*pに10を代入すると、iも自動的に10に切り替わると言うのではなく、
>この2つはそもそも同じメモリ位置を示しているのです。

>ポインタの本当の使い方は、ショートカットとして使用することです。
>ショートカットはどこにでも自由に作ることができますし、
>複数個作ったり削除したりしても、指し示すファイルには何の影響もありません。

ポインタ変数に実際に存在する変数のアドレスを記憶しておけば、そのポインタ変数が使える場所であれば、もとの変数が使えない場所であっても、もとの変数と同じように使うことができる。
